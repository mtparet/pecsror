<!DOCTYPE html>
<html>
  <head>
    <title>Images sequentielles</title>
  </head>
  <body>


<script type="text/javascript">


  /* tableau de l'ordre des images tel que l'utilisateur va les place*/
  var tab_order = <%= array_or_string_for_javascript(@tab_order) %>;

  /* tableau de l'ordre correct */
  var tab_correct = <%= array_or_string_for_javascript(@tab_correct) %>;

  /* tableau de l'ordre des boxs des images */
  var tab_box = <%= array_or_string_for_javascript(@tab_box) %>;
  
  /* Insérer dans tableau de taille fixe de l'élément id_name à la place num_place
    Si la place en dehors du tableau on ne fait rien
    Si la place était avant vide on a simplement une insertion à cette place
    Si la place était occupée, le reste du tableau est déplacé:
        soit sur la droite ou la gauche en fonction du plus grand nombre de place vide restant à la fin du tableau
        Si il ne reste plus de place à la toute fin du tableau de chaque côté, il est déplacé :
          soit à droite ou gauche en fonction des places vides non finales */ 
  function insert_at(id_name,num_place,tab){
    var temp_name = id_name;
    var temp_name2;

    if(num_place < tab.length){
      if(tab[num_place] == "null"){
        tab[num_place] = id_name;
      }else{
      var free_right = what_free("right", true, num_place, tab);
      var free_left = what_free("left", true, num_place, tab);
      
      // on test si le nombre d'élément dans free_left est > à celui dans free_right et qu'il n'est donc pas égal à 0
      if(free_left.length > free_right.length){
       tab.splice(free_left[0],1);
       return insert_classic(num_place,id_name,tab);
      }else{
        // si on vérifie que l'un des deux ne sont pas égal à 0 (et donc que free_right n'est pas égal à 0)
        if(free_right.length != 0 || free_left.length != 0){
          tab.splice(free_right[0],1);
          return insert_classic(num_place,id_name,tab);
        }else
        // sinon on recommence en prenant en compte toutes les cases
        {
           var free_right = what_free("right", false, num_place, tab);
           var free_left = what_free("left", false, num_place, tab);
// on test si le nombre d'élément dans free_left est > à celui dans free_right et qu'il n'est donc pas égal à 0
          if(free_left.length > free_right.length){
           tab.splice(free_left[0],1);
           return insert_classic(num_place,id_name,tab);
          }else{
            // si on vérifie que l'un des deux ne sont pas égal à 0 (et donc que free_right n'est pas égal à 0)
            if(free_right.length != 0 || free_left.length != 0){
              tab.splice(free_right[0],1);
              return insert_classic(num_place,id_name,tab);
            }
			return tab;
            }
			return tab;
        }
		return tab;
      }
		return tab;
      
      }
		return tab;
    }
	return tab;
  }
  
  /* insertion classique dans un tableau avec décalage à droite */
  function insert_classic(num_place, id_name,tab){
    if(num_place == 0){
      tab.unshift(id_name);
    }else{
      if(num_place == tab.length ){
        tab.push(id_name);     
      }else{
        var tab_right = tab.slice(num_place);
        tab_right.unshift(id_name);
        
        for(i = (num_place - 1); i >= 0; i--){
          tab_right.unshift(tab[i]);
        }
        
        tab = tab_right;
      }
    }
    return tab;
  }

  /* calcul le nombre de place vide à partir d'une certaine place dans un tableau :
    à gauche, droite, qu'à la fin, de partout
  side : left ou right
  only_end : true or false
  num_place : le numéro de la place
  tab : le tableau
  renvoit un tableau avec les numéros des places libres suivant les conditions
  l'odre des places dans le tableau est indicatif pour le premier élément à supprimer si réorganisation du tableau
  */
  function what_free(side, only_end, num_place, tab){
    var tab_free = new Array();
    if(num_place < tab.length){
      if(side == "left"){
        if(only_end){
          var i = 0;
          var case_prev;
          do{
              case_prev = tab[i];
              if(case_prev == "null"){
                tab_free.push(i);
              }
              i++;
            }
          while( case_prev == "null" && i <= num_place)
        }else{
          for(i = num_place; i >= 0; i--){
            if(tab[i] == "null"){
              tab_free.push(i);
            }
          }
        }
      }else{ 
        if (side == "right"){
          if(only_end){
          var i = tab.length - 1;
          var case_prev;
          do{
              case_prev = tab[i];
              if(case_prev == "null"){
                tab_free.push(i);
              }
              i--;
            }
          while( case_prev == "null" && i >= num_place)
        }else{
          for(i = num_place; i < tab.length; i++){
            if(tab[i] == "null"){
              tab_free.push(i);
            }
          }
         }
        }
      }
     return tab_free;
    } 
  }

  /* on déplace id_name à la place num_place 
	pour se faire on stocke l'élément à déplacer, on libère la place où il était
	et on appelle la fonction d'insertion */
  function move_at(id_name,num_place){
    var index_id = tab_order.indexOf(id_name);
	tab_order[index_id] = "null";
	return insert_at(id_name,num_place,tab_order);
  }

  
	function drag(target, evt) {
		evt.dataTransfer.setData("Text", target.id);
	
	}

	function drop(target, evt) {
		var id = evt.dataTransfer.getData("Text");

    /* nom/id de l'image déplacé */
		var id_name = document.getElementById(id).id;

    var parent = target.parentNode;
    var target_id = target.id;
    var element_drag = document.getElementById(id);
    var parent_image = element_drag.parentNode;

    /* on détermine le numéro de la case dans tab_box */
    var target_place = tab_box.indexOf(target.id)

    /* on teste si l'image provient déjà de la liste */
    if(parent_image.className == "box2"){

      /* on teste si on va réellement déplacer l'image*/
      var image_place = tab_order.indexOf(element_drag.id);

      /* on vérifie que l'on ne déplace pas l'image sur elle-même .. */
      if(image_place != target_place){
          tab_order = move_at(id_name,target_place);
        }
 
      }else{  
       	 tab_order = insert_at(id_name,target_place,tab_order);  
    }

      /* reconstruire de l'affichage des images */
      rebuild_box();
	  evt.preventDefault();
    
      /* on lance la vérification de l'ordre */
      check_order();
  }
    /*function find_place(target){
      if( target.className == "box_insert"){
        /* tester si case ensuite 
        if(){
        }
        
      }else{
        /* on détermine le numéro de la case dans tab_box 
        var target_place = tab_box.indexOf(target.id)
      }
    }*/

    function checkorder(id_name){
      var tab_order_length = tab_order.length;

      //si il n'y a qu'une image on ne peut pas tester
      if(tab_order_length > 1){

        var index_order = tab_order.indexOf(id_name);
        var index_correct = tab_correct.indexOf(id_name);
        
        //si un autre image ne peut être que a droite
        if(index_order == 0){
          //on test si l'image à droite est la même dans les deux tableaux
          if(((index_correct + 1) < tab_correct.length ) && (tab_order[index_order + 1] == tab_correct[index_correct + 1])){
            smiley = document.getElementById("smiley_good").cloneNode(true);
          }else{
            smiley = document.getElementById("smiley_bad").cloneNode(true);
          } 
        //sinon on test l'image à gauche
        //TODO : préviligier la plus longue chaine juste
        }else{
          if(((index_correct - 1) >= 0 ) && (tab_order[index_order - 1] == tab_correct[index_correct - 1])){
            smiley = document.getElementById("smiley_good").cloneNode(true);
          }else{
          //sinon on test il y a une image à droite
            if(((index_correct + 1) < tab_order.length ) && ((index_correct + 1) < tab_correct.length ) && (tab_order[index_order + 1] == tab_correct[index_correct + 1])){
                 smiley = document.getElementById("smiley_good").cloneNode(true);
            }else{
               smiley = document.getElementById("smiley_bad").cloneNode(true);
            }
           
          } 
        }

        smiley.id += id_name;
        smiley.style.display = "";
        return smiley;
      }
    }

    function check_order(){
    var id_name ;
    var image_parent;
    var smiley_current;
    var smiley;
      if(tab_order.length > 1 ){
        for(i = 0; i < tab_order.length; i++){
          id_name = tab_order[i];
          image_parent = document.getElementById(id_name).parentNode;
          smiley_current = image_parent.getElementsByClassName("smiley")[0];
          if(smiley_current != null){
            image_parent.removeChild(smiley_current);
          }
          smiley = checkorder(id_name)
          image_parent.insertBefore(smiley,document.getElementById(id_name))
        }
        
      } 
    }

  function rebuild_box(){
      box_old = document.getElementById("box_in"); 
      //for(var i = 0; i < target.children.length; i++){
      //  target.removeChild(target.children[i]); 
      //} 
        var box_in = document.createElement("div");
        box_in.className = "box_in";
        box_in.id = "box_in";

      for(i = 0; i < tab_order.length; i++){
          var box = document.createElement("div");
          box.className = "box2";
		  box.id = tab_box[i];
          box.setAttribute("ondragover", "return false");
          box.setAttribute("ondrop","drop(this, event)");

          if(tab_order[i] != "null"){
            box.appendChild(document.getElementById(tab_order[i]));
          }

          box_in.appendChild(box);
      }
      
      box_old.parentNode.replaceChild(box_in,box_old);
    }

	
</script>

  
	<!-- parcourt de la liste des catégories et affichage de l'image correspondant -->
	 <% for sequence in @list_sequence.collect do %> 
    <%= sequence.name %>
    <% unless sequence.sequence_liste.first.image.image_file.nil? %>
    <%= link_to(image_tag(sequence.sequence_liste.first.image.image_file.thumb.url), {:controller => "image_sequentielle", :action => 'display_sequence', :sequence_name => sequence.name}, :remote => true) %>
  <% end %>
	<% end %>

  <div id="sequence">
    <%= render :partial => "sequence" %>
  </div>

  <div id="box_in" class="box_in">
    <%= render :partial => "box_in" %>
  </div>

  <%= render :partial => "smiley" %>
  <div></div>
  <div>
  <%= link_to 'Retour aux menus', {:controller => 'home', :action => 'index'} %>
  </div>
  
  </body>
</html>
